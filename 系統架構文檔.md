# CPC Server Collector System - 系統架構文檔

**版本**: v5.1.3.4
**最後更新**: 2025-10-14
**文檔類型**: 系統架構設計文檔

---

## 目錄

1. [系統概述](#1-系統概述)
2. [系統架構](#2-系統架構)
3. [核心組件](#3-核心組件)
4. [資料流程](#4-資料流程)
5. [資料庫設計](#5-資料庫設計)
6. [通訊協議](#6-通訊協議)
7. [部署架構](#7-部署架構)
8. [安全性設計](#8-安全性設計)
9. [擴展性設計](#9-擴展性設計)
10. [附錄](#10-附錄)

---

## 1. 系統概述

### 1.1 系統簡介

CPC Server Collector System 是一個分散式音訊錄製、管理與智能分析平台。系統採用三層架構設計，支援多個邊緣設備同時錄製音訊，並透過機器學習模型自動分析音訊特徵，實現異常音訊檢測功能。

### 1.2 主要功能

- **分散式音訊錄製**: 支援多個邊緣設備同時進行音訊採集
- **即時管理介面**: 提供 Web 儀表板進行設備管理與錄音排程
- **自動化分析流程**: 三階段音訊分析（切割、特徵提取、分類）
- **檔案完整性驗證**: SHA-256 雜湊值驗證確保資料完整性
- **即時通訊**: 基於 WebSocket 的即時狀態更新
- **大檔案儲存**: 使用 GridFS 儲存音訊檔案

### 1.3 技術堆疊

#### 後端技術
- **Web 框架**: Flask 3.0.3
- **即時通訊**: Flask-SocketIO 5.3.6
- **資料庫**:
  - MongoDB 6.0 (主要資料存儲)
  - GridFS (音訊檔案存儲)
  - SQLite (排程資料，可選)

#### 音訊處理
- **音訊處理**: librosa 0.11.0, sounddevice 0.5.2, soundfile 0.13.1
- **深度學習**:
  - PyTorch 2.8.0+cu129
  - torchaudio 2.8.0
  - SpeechBrain 1.0.3
- **機器學習**: scikit-learn 1.7.2

#### 其他
- **數據處理**: numpy 2.3.3, pandas 2.3.3
- **視覺化**: matplotlib 3.10.6, seaborn 0.13.2

---

## 2. 系統架構

### 2.1 整體架構圖

```
┌─────────────────────────────────────────────────────────────────┐
│                         使用者層                                  │
├─────────────────────────────────────────────────────────────────┤
│  Web 瀏覽器                   邊緣設備客戶端 (n 台)                │
│  - 儀表板管理                 - 自動音訊錄製                       │
│  - 錄音播放                   - 檔案上傳                          │
│  - 排程設定                   - 狀態回報                          │
└──────────┬──────────────────────────────┬───────────────────────┘
           │                              │
           │ HTTP/WebSocket               │ SocketIO
           │                              │
┌──────────▼──────────────────────────────▼───────────────────────┐
│                         應用層                                    │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐          ┌──────────────────────┐      │
│  │  Flask Frontend     │          │  Analysis Backend    │      │
│  │  (Port 5000)        │          │  (分析服務)            │      │
│  ├─────────────────────┤          ├──────────────────────┤      │
│  │ • HTTP Routes       │          │ • MongoDB Watcher    │      │
│  │ • SocketIO Events   │          │ • Analysis Pipeline  │      │
│  │ • Schedule Manager  │          │ • Audio Slicer       │      │
│  │ • Device Manager    │          │ • LEAF Extractor     │      │
│  │ • GridFS Handler    │          │ • RF Classifier      │      │
│  └──────────┬──────────┘          └──────────┬───────────┘      │
│             │                                 │                  │
└─────────────┼─────────────────────────────────┼──────────────────┘
              │                                 │
              │ MongoDB Driver                  │ MongoDB Driver
              │                                 │
┌─────────────▼─────────────────────────────────▼──────────────────┐
│                         資料層                                    │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                  MongoDB (Port 27020)                   │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  • recordings Collection (錄音元資料)                     │    │
│  │  • fs.files / fs.chunks (GridFS 音訊檔案)                │    │
│  │  • 索引: AnalyzeUUID, device_id, upload_time, etc.      │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 三層架構設計

#### 第一層：使用者層 (Presentation Layer)
- **Web 瀏覽器**: 透過 HTTP/WebSocket 連接至 Flask 前端
- **邊緣設備**: 透過 SocketIO 連接至 Flask 前端，執行音訊錄製

#### 第二層：應用層 (Application Layer)
- **Flask Frontend**: 處理使用者請求、設備管理、檔案上傳
- **Analysis Backend**: 監聽 MongoDB 變更、執行音訊分析流程

#### 第三層：資料層 (Data Layer)
- **MongoDB**: 儲存所有錄音元資料與分析結果
- **GridFS**: 儲存音訊檔案二進制資料

### 2.3 服務交互模式

```
┌──────────────┐                    ┌──────────────┐
│ Edge Client  │◄──────record──────►│   Flask      │
│              │                    │   Frontend   │
│              │─────upload────────►│              │
└──────────────┘                    └───────┬──────┘
                                            │
                                     insert │ MongoDB
                                            │
                      ┌─────────────────────▼──────┐
                      │      MongoDB                │
                      │  (Change Stream/Polling)    │
                      └─────────────────────┬───────┘
                                            │
                                      watch │ changes
                                            │
                      ┌─────────────────────▼──────┐
                      │  Analysis Backend          │
                      │  1. Slicer                 │
                      │  2. LEAF Extractor         │
                      │  3. Classifier             │
                      └────────────────────────────┘
```

---

## 3. 核心組件

### 3.1 Flask Frontend (前端服務)

#### 3.1.1 職責範圍
- HTTP API 路由處理
- SocketIO 事件管理
- 設備註冊與狀態管理
- 錄音檔案上傳與下載
- 排程管理
- GridFS 檔案操作

#### 3.1.2 主要模組

##### flask_main.py
系統入口點，初始化 Flask 應用與相關組件。

```python
主要功能:
- Flask App 初始化
- SocketIO 初始化 (CORS 允許所有來源)
- MongoDB 連接初始化
- SQLAlchemy 初始化 (用於排程)
- 啟動參數: host='0.0.0.0', port=5000
```

##### routes.py
HTTP 路由處理器，提供 RESTful API。

**主要路由**:

| 路由 | 方法 | 說明 |
|------|------|------|
| `/` | GET | 首頁 |
| `/dashboard` | GET | 管理儀表板（分頁、排序） |
| `/upload_recording` | POST | 上傳錄音檔案（支援 GridFS） |
| `/recordings` | GET | 獲取所有錄音列表 |
| `/download/<id>` | GET | 下載指定錄音（從 GridFS） |
| `/play/<id>` | GET | 播放錄音頁面 |
| `/delete/<id>` | POST | 刪除錄音（包含 GridFS 檔案） |
| `/schedule` | POST | 建立錄音排程 |
| `/schedule/<device_id>` | GET/DELETE | 取得/刪除排程 |
| `/schedule_management` | GET | 排程管理頁面 |

**檔案上傳流程** (`upload_recording`):
1. 驗證檔案存在性
2. 讀取檔案內容並計算 SHA-256 雜湊值
3. 驗證檔案完整性（設備上傳時）
4. 讀取音訊元資料（採樣率、聲道數、格式）
5. 上傳到 GridFS
6. 建立 MongoDB 記錄
7. 發送 SocketIO 事件通知

##### socket_events.py
SocketIO 事件處理器，管理即時通訊。

**事件列表**:

| 事件 | 方向 | 說明 |
|------|------|------|
| `connect` | Client→Server | 客戶端連接 |
| `disconnect` | Client→Server | 客戶端斷線 |
| `register_device` | Client→Server | 設備註冊 |
| `request_id` | Client→Server | 請求新設備 ID |
| `update_status` | Client→Server | 更新設備狀態 |
| `start_recording` | Client→Server | 開始錄音命令 |
| `update_device_name` | Client→Server | 更新設備名稱 |
| `record` | Server→Client | 伺服器下發錄音指令 |
| `update_devices` | Server→Client | 廣播設備列表更新 |
| `new_recording` | Server→Client | 廣播新錄音通知 |
| `assign_id` | Server→Client | 分配新設備 ID |

**排程檢查器** (`schedule_checker`):
- 背景任務，每秒執行一次
- 檢查所有設備的排程時間
- 使用設備級鎖避免重複執行
- 自動發送 `record` 事件觸發錄音

##### models.py
資料模型與資料庫操作層。

**核心類別**:

1. **MongoDBHandler**: MongoDB 連接管理器
   - 建立連接與索引
   - 初始化 GridFS Handler
   - 連接健康檢查

2. **AudioRecording**: 錄音記錄模型
   - 屬性: analyze_uuid, filename, duration, device_id, file_size, file_hash, file_id, metadata
   - `to_mongodb_document()`: 轉換為 MongoDB 文檔格式
   - `from_mongodb_document()`: 從 MongoDB 文檔還原物件
   - `to_dict()`: 轉換為字典（API 回應）

3. **RecordingRepository**: 資料存取層
   - `insert()`: 新增錄音記錄
   - `find_all()`: 查詢所有記錄
   - `find_by_uuid()`: 根據 UUID 查詢
   - `delete_by_uuid()`: 刪除記錄（包含 GridFS 檔案）
   - `count()`: 統計總數
   - `get_statistics()`: 獲取統計資訊

##### shared_state.py
全域狀態管理。

```python
# 全域字典
connected_clients = {}      # {sid: {id, type}}
recording_devices = {}      # {device_id: {id, name, status}}
device_schedules = {}       # {device_id: RecordingSchedule}

# RecordingSchedule 類別
class RecordingSchedule:
    - interval: 錄音間隔（分鐘）
    - duration: 錄音時長（秒）
    - count: 錄音次數（None = 無限）
    - current_count: 目前執行次數
    - next_recording_time: 下次錄音時間
```

##### gridfs_handler.py
GridFS 檔案操作封裝。

**主要方法**:
- `upload_file()`: 上傳檔案到 GridFS
- `download_file()`: 從 GridFS 下載檔案
- `delete_file()`: 刪除 GridFS 檔案
- `file_exists()`: 檢查檔案是否存在
- `get_file_info()`: 獲取檔案元資料

#### 3.1.3 設定檔案 (config.py)

```python
# MongoDB 配置
MONGODB_CONFIG = {
    'host': 'localhost',
    'port': 27020,
    'username': 'web_ui',
    'password': 'hod2iddfsgsrl',
    'database': 'web_db',
    'collection': 'recordings'
}

# 資料集配置
DATASET_CONFIG = {
    'dataset_UUID': 'WEB_UI_Dataset',
    'obj_ID': '99'
}

# 音訊配置
AUDIO_CONFIG = {
    'sample_rate': 44100,
    'channels': 1,
    'default_format': 'wav'
}
```

---

### 3.2 Analysis Backend (分析服務)

#### 3.2.1 職責範圍
- 監聽 MongoDB 新記錄
- 執行三階段音訊分析流程
- 更新分析狀態與結果
- 臨時檔案管理

#### 3.2.2 主要模組

##### analysis_main.py
分析服務主程式，服務生命週期管理。

**AnalysisService 類別**:
```python
主要屬性:
- mongodb_handler: MongoDB 處理器
- watcher: MongoDB 監聽器
- pipeline: 分析流程管理器
- task_queue: 任務佇列
- worker_threads: 工作執行緒列表
- processing_records: 正在處理的記錄集合（防重複）
- processing_lock: 執行緒鎖

主要方法:
- initialize(): 初始化所有組件
- start(): 啟動服務（處理現有記錄 + 開始監聽）
- stop(): 停止服務並清理資源
- _start_workers(): 啟動 N 個工作執行緒
- _worker(): 工作執行緒主循環
- _on_new_record(): 新記錄回調函數
```

**並發處理機制**:
- 使用 `Queue` 管理待處理任務
- 支援多執行緒並發處理（可配置執行緒數）
- 使用 `processing_records` 集合防止重複處理
- 執行緒鎖確保併發安全

##### mongodb_watcher.py
MongoDB 變更監聽器，支援兩種模式。

**監聽模式**:

1. **Change Stream 模式** (推薦)
   - 即時監聽 MongoDB 變更事件
   - 低延遲、高效率
   - 需要 MongoDB Replica Set

2. **輪詢模式** (備用)
   - 定期查詢 `current_step = 0` 的記錄
   - 不需要 Replica Set
   - 配置間隔: 5 秒（可調整）

**MongoDBWatcher 類別**:
```python
主要方法:
- start(): 開始監聽（根據配置選擇模式）
- stop(): 停止監聽
- _watch_with_change_stream(): Change Stream 模式
- _watch_with_polling(): 輪詢模式
- _handle_change(): 處理變更事件
- process_existing_records(): 處理啟動時的待處理記錄
```

##### analysis_pipeline.py
分析流程管理器，協調三個處理步驟。

**AnalysisPipeline 類別**:
```python
主要屬性:
- mongodb: MongoDB 處理器
- gridfs_handler: GridFS 處理器
- slicer: 音訊切割器 (Step 1)
- leaf_extractor: LEAF 特徵提取器 (Step 2)
- classifier: 音訊分類器 (Step 3)

主要方法:
- process_record(): 處理單一記錄的完整流程
- _get_audio_file(): 從 GridFS 獲取音訊檔案
- _execute_step1(): 執行 Step 1 (音訊切割)
- _execute_step2(): 執行 Step 2 (LEAF 特徵提取)
- _execute_step3(): 執行 Step 3 (分類)
- _mark_error(): 標記錯誤狀態
- cleanup(): 清理資源
```

**處理流程**:
1. 檢查記錄是否已處理
2. 從 GridFS 下載音訊檔案到臨時檔案
3. 依序執行三個步驟
4. 更新 MongoDB 狀態
5. 清理臨時檔案

##### processors/step1_slicer.py
音訊切割處理器。

**AudioSlicer 類別**:
```python
配置參數:
- slice_duration: 0.16 秒（切片長度）
- slice_interval: 0.20 秒（切片間隔）
- sample_rate: 16000 Hz
- channels: [6]（處理的通道）
- min_segment_duration: 0.05 秒

主要方法:
- slice_audio(filepath): 切割音訊檔案
- _perform_slicing(audio, sr): 執行實際切割
- validate_filepath(filepath): 驗證檔案路徑
- get_audio_info(filepath): 獲取音訊資訊

輸出格式:
[
    {
        'selec': 1,
        'channel': 6,
        'start': 0.0,
        'end': 0.16,
        'bottom_freq': 0.002,
        'top_freq': 8.0
    },
    ...
]
```

##### processors/step2_leaf.py
LEAF 特徵提取處理器。

**LEAFFeatureExtractor 類別**:
```python
LEAF 模型配置:
- n_filters: 40（濾波器數量）
- sample_rate: 16000 Hz
- window_len: 25.0 ms
- window_stride: 10.0 ms
- pcen_compression: True
- min_freq: 60 Hz
- max_freq: 8000 Hz

主要方法:
- extract_features(filepath, slice_data): 提取 LEAF 特徵
- _load_audio_segment(): 載入音訊片段
- _extract_single_feature(): 提取單一特徵
- get_feature_info(): 獲取特徵資訊
- cleanup(): 清理模型資源

輸出格式（簡化）:
[
    [feat_value_1],
    [feat_value_2],
    ...
]
```

##### processors/step3_classifier.py
音訊分類器（隨機森林模型）。

**AudioClassifier 類別**:
```python
配置:
- method: 'rf_model'（使用隨機森林模型）
- classes: ['normal', 'abnormal']
- model_path: 'models/rf_model_cpu_final.pkl'

主要方法:
- classify(leaf_features): 分類 LEAF 特徵
- _load_model(): 載入隨機森林模型
- _random_classification(): 隨機分類（備用）

輸出格式:
{
    'features_data': [
        {'prediction': 'normal', 'confidence': 0.85},
        {'prediction': 'abnormal', 'confidence': 0.72},
        ...
    ],
    'processor_metadata': {
        'processor_name': 'RandomForest_Classifier',
        'model_version': '1.0',
        'total_segments': 100,
        'normal_count': 70,
        'abnormal_count': 30,
        'final_prediction': 'normal'
    }
}
```

##### utils/mongodb_handler.py
MongoDB 操作工具類。

**MongoDBHandler 類別**:
```python
主要方法:
- get_record_by_uuid(): 根據 UUID 獲取記錄
- find_pending_records(): 查找待處理記錄
- update_record_step(): 更新處理步驟與狀態
- save_slice_results(): 儲存切割結果
- save_leaf_features(): 儲存 LEAF 特徵
- save_classification_results(): 儲存分類結果
- try_claim_record(): 嘗試認領記錄（防重複處理）
- watch_changes(): 監聽 Change Stream
```

#### 3.2.3 設定檔案 (config.py)

```python
# 音訊處理配置
AUDIO_CONFIG = {
    'slice_duration': 0.16,
    'slice_interval': 0.20,
    'channels': [6],
    'sample_rate': 16000,
    'min_segment_duration': 0.05
}

# LEAF 特徵提取配置
LEAF_CONFIG = {
    'n_filters': 40,
    'sample_rate': 16000,
    'window_len': 25.0,
    'window_stride': 10.0,
    'pcen_compression': True,
    'batch_size': 32,
    'device': 'cpu'
}

# 分類配置
CLASSIFICATION_CONFIG = {
    'method': 'rf_model',
    'classes': ['normal', 'abnormal'],
    'model_path': 'models'
}

# 服務配置
SERVICE_CONFIG = {
    'use_change_stream': False,
    'polling_interval': 5,
    'max_concurrent_tasks': 3,
    'retry_attempts': 3,
    'retry_delay': 2
}

# GridFS 配置
USE_GRIDFS = True
```

---

### 3.3 Edge Client (邊緣設備客戶端)

#### 3.3.1 職責範圍
- 音訊設備管理
- 自動音訊錄製
- 檔案完整性驗證
- 檔案上傳
- 狀態回報

#### 3.3.2 主要模組

##### edge_client.py
邊緣設備客戶端主程式。

**AudioRecorder 類別**:
```python
配置參數:
- RESPEAKER_RATE: 16000 Hz
- RESPEAKER_CHANNELS: 1
- SERVER_URL: 伺服器地址
- CONFIG_FILE: 'device_config.json'
- TEMP_WAV_DIR: 'temp_wav'

主要方法:
- load_config(): 載入設備配置
- save_config(): 儲存設備配置
- calculate_file_hash(): 計算 SHA-256 雜湊值
- list_audio_devices(): 列出可用音訊設備
- record_audio(): 錄製音訊
- upload_audio(): 上傳音訊檔案
- connect_to_server(): 連接伺服器（指數退避重試）
- register_device(): 註冊設備
- run(): 主循環
```

**SocketIO 事件處理**:
- `on_connect`: 連接成功，註冊設備
- `on_disconnect`: 連接斷開
- `assign_id`: 接收伺服器分配的設備 ID
- `on_record`: 接收錄音指令，執行錄音與上傳
- `on_update_device_name`: 更新設備名稱
- `on_update_devices`: 同步設備列表

**錄音流程**:
1. 接收 `record` 事件（包含錄音時長）
2. 查詢音訊設備資訊
3. 錄製音訊並儲存為 WAV 檔案
4. 計算檔案大小與 SHA-256 雜湊值
5. 上傳檔案與元資料到伺服器
6. 更新設備狀態為 IDLE

**設備配置檔案格式** (device_config.json):
```json
{
  "device_id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "device_name": "Device_name"
}
```

---

## 4. 資料流程

### 4.1 錄音上傳流程

```
┌────────────┐
│ Edge Client│
└─────┬──────┘
      │ 1. 接收 record 事件
      ▼
┌─────────────────┐
│ 錄製音訊         │
│ - duration: 10s │
│ - format: WAV   │
└─────┬───────────┘
      │ 2. 計算檔案資訊
      ▼
┌──────────────────────┐
│ 檔案完整性資訊        │
│ - file_size         │
│ - file_hash (SHA256)│
└─────┬────────────────┘
      │ 3. POST /upload_recording
      ▼
┌────────────────────────┐
│ Flask Frontend         │
│ - 驗證檔案完整性        │
│ - 讀取音訊元資料        │
└─────┬──────────────────┘
      │ 4. 上傳到 GridFS
      ▼
┌────────────────────────┐
│ GridFS                 │
│ - 儲存 fs.files        │
│ - 儲存 fs.chunks       │
└─────┬──────────────────┘
      │ 5. 建立 MongoDB 記錄
      ▼
┌──────────────────────────────┐
│ MongoDB recordings Collection│
│ - AnalyzeUUID                │
│ - files.raw.fileId           │
│ - info_features              │
│ - current_step: 0            │
└─────┬────────────────────────┘
      │ 6. 發送 SocketIO 事件
      ▼
┌────────────────────────┐
│ 廣播 new_recording     │
│ - 所有 Web 客戶端      │
└────────────────────────┘
```

### 4.2 分析處理流程

```
┌──────────────────────┐
│ MongoDB 新記錄插入    │
│ current_step: 0      │
└──────┬───────────────┘
       │
       │ Change Stream / Polling
       ▼
┌──────────────────────┐
│ MongoDB Watcher      │
│ - 偵測到新記錄        │
└──────┬───────────────┘
       │ callback
       ▼
┌──────────────────────┐
│ 加入任務佇列          │
│ (Task Queue)         │
└──────┬───────────────┘
       │
       │ Worker Thread 取得任務
       ▼
┌─────────────────────────────────┐
│ Analysis Pipeline               │
└─────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ Step 0: 獲取音訊檔案             │
│ - 從 GridFS 下載                 │
│ - 建立臨時檔案                   │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ Step 1: 音訊切割 (Slicer)        │
│ - 載入音訊 (librosa)             │
│ - 滑動視窗切割                   │
│ - 輸出: 切片時間資訊             │
│ - 更新: current_step = 1        │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ Step 2: LEAF 特徵提取            │
│ - 載入 SpeechBrain LEAF 模型     │
│ - 批次處理切片                   │
│ - 輸出: 特徵向量陣列             │
│ - 更新: current_step = 2        │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ Step 3: 分類 (Random Forest)     │
│ - 載入 RF 模型                   │
│ - 預測每個切片                   │
│ - 計算統計資訊                   │
│ - 更新: current_step = 3        │
│ - 更新: analysis_status = completed │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ 分析結果儲存                     │
│ - analyze_features[0]: 切割     │
│ - analyze_features[1]: LEAF     │
│ - analyze_features[2]: 分類     │
│ - analysis_summary: 統計摘要    │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│ 清理臨時檔案                     │
└─────────────────────────────────┘
```

### 4.3 即時通訊流程

#### 設備註冊流程

```
Edge Client                 Flask Frontend
     │                            │
     │───connect─────────────────>│
     │                            │
     │<──connected────────────────│
     │                            │
     │───register_device─────────>│
     │   {client_id, device_name} │
     │                            │
     │                            ├──更新 recording_devices
     │                            ├──更新 connected_clients
     │                            │
     │<──update_devices───────────│ (廣播)
     │                            │
```

#### 排程錄音流程

```
Web Browser              Flask Frontend              Edge Client
     │                         │                          │
     │──POST /schedule────────>│                          │
     │                         │                          │
     │                         ├──建立 RecordingSchedule   │
     │                         │                          │
     │<──response──────────────│                          │
     │                         │                          │
     │                         │  [Background Task]       │
     │                         │  每秒檢查排程             │
     │                         │                          │
     │                         ├──時間到達                │
     │                         │                          │
     │                         │──emit record────────────>│
     │                         │  {duration: 10}          │
     │                         │                          │
     │                         │                          ├──開始錄音
     │                         │                          │
     │                         │<──update_status──────────│
     │                         │  {status: RECORDING}     │
     │                         │                          │
     │                         │                          ├──完成錄音
     │                         │                          │
     │                         │<──POST /upload_recording─│
     │                         │                          │
     │                         ├──儲存到 GridFS & MongoDB  │
     │                         │                          │
     │                         │──new_recording─────────> │ (廣播)
     │<──new_recording─────────│                          │
     │                         │                          │
     │                         │<──update_status──────────│
     │                         │  {status: IDLE}          │
     │                         │                          │
```

---

## 5. 資料庫設計

### 5.1 MongoDB Collections

#### 5.1.1 recordings Collection

**文檔結構**:

```javascript
{
  // ========== 主鍵 ==========
  "_id": ObjectId("..."),
  "AnalyzeUUID": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",

  // ========== 狀態欄位 ==========
  "current_step": 0,              // 0-4: 處理步驟
  "analysis_status": "pending",   // pending, processing, completed, error
  "error_message": "",            // 錯誤訊息（如果有）

  // ========== 時間戳記 ==========
  "created_at": ISODate("2025-10-14T12:00:00Z"),
  "updated_at": ISODate("2025-10-14T12:00:00Z"),

  // ========== 檔案資訊 ==========
  "files": {
    "raw": {
      "fileId": ObjectId("..."),  // GridFS 檔案 ID
      "filename": "Device_20251014_120000.wav",
      "type": "wav"
    }
  },

  // ========== 基本資訊 ==========
  "info_features": {
    "dataset_UUID": "WEB_UI_Dataset",
    "obj_ID": "99",
    "device_id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
    "testing": false,
    "upload_time": "2025-10-14T12:00:00+08:00",
    "upload_complete": true,
    "file_hash": "abcdef1234567890...",
    "file_size": 256000,
    "duration": 10.0,
    "web_ui_metadata": {
      "sample_rate": 16000,
      "channels": 1,
      "format": "wav",
      "source": "EDGE_DEVICE"  // 或 "WEB_UPLOAD"
    }
  },

  // ========== 分析特徵 ==========
  "analyze_features": [
    // [0] Step 1: 切割結果
    {
      "processor_name": "Audio_Slicer",
      "version": "1.0",
      "created_at": ISODate("2025-10-14T12:00:10Z"),
      "features_data": [
        {
          "selec": 1,
          "channel": 6,
          "start": 0.0,
          "end": 0.16,
          "bottom_freq": 0.002,
          "top_freq": 8.0
        },
        // ... 更多切片
      ]
    },

    // [1] Step 2: LEAF 特徵
    {
      "processor_name": "LEAF_Feature_Extractor",
      "version": "1.0",
      "model": "speechbrain/leaf",
      "created_at": ISODate("2025-10-14T12:00:20Z"),
      "features_data": [
        [123.45],  // 特徵值（簡化格式）
        [234.56],
        // ... 更多特徵
      ],
      "processor_metadata": {
        "n_filters": 40,
        "sample_rate": 16000,
        "window_len": 25.0,
        "window_stride": 10.0
      }
    },

    // [2] Step 3: 分類結果
    {
      "processor_name": "RandomForest_Classifier",
      "version": "1.0",
      "model": "rf_model_cpu_final.pkl",
      "created_at": ISODate("2025-10-14T12:00:30Z"),
      "features_data": [
        {
          "prediction": "normal",
          "confidence": 0.85
        },
        {
          "prediction": "abnormal",
          "confidence": 0.72
        },
        // ... 更多預測
      ],
      "processor_metadata": {
        "processor_name": "RandomForest_Classifier",
        "model_version": "1.0",
        "total_segments": 100,
        "normal_count": 70,
        "abnormal_count": 30,
        "unknown_count": 0,
        "final_prediction": "normal"
      }
    }
  ],

  // ========== 分析摘要（前端顯示用） ==========
  "analysis_summary": {
    "total_segments": 100,
    "normal_count": 70,
    "abnormal_count": 30,
    "unknown_count": 0,
    "final_prediction": "normal"
  }
}
```

**索引設計**:

```javascript
// 主鍵索引（自動建立）
{ "_id": 1 }

// 業務索引
{ "AnalyzeUUID": 1 }              // 唯一識別碼
{ "info_features.device_id": 1 }  // 設備查詢
{ "info_features.upload_time": 1 }// 時間排序
{ "info_features.file_hash": 1 }  // 檔案查重
{ "files.raw.filename": 1 }       // 檔案名稱查詢
{ "current_step": 1 }              // 待處理記錄查詢
{ "analysis_status": 1 }           // 狀態查詢

// 複合索引（效能優化）
{ "current_step": 1, "analysis_status": 1 }
```

#### 5.1.2 GridFS Collections

**fs.files** (檔案元資料):

```javascript
{
  "_id": ObjectId("..."),
  "length": 256000,               // 檔案大小（bytes）
  "chunkSize": 261120,            // 分塊大小（預設 255KB）
  "uploadDate": ISODate("2025-10-14T12:00:00Z"),
  "filename": "Device_20251014_120000.wav",
  "contentType": "audio/wav",
  "metadata": {
    "device_id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
    "upload_time": "2025-10-14T12:00:00+08:00",
    "file_hash": "abcdef1234567890..."
  }
}
```

**fs.chunks** (檔案分塊資料):

```javascript
{
  "_id": ObjectId("..."),
  "files_id": ObjectId("..."),    // 關聯到 fs.files._id
  "n": 0,                         // 分塊序號
  "data": BinData(...)            // 二進制資料
}
```

### 5.2 資料生命週期

```
┌────────────────┐
│ 錄音上傳        │ current_step = 0, analysis_status = "pending"
└───────┬────────┘
        │
        ▼
┌────────────────┐
│ 音訊切割        │ current_step = 1, analysis_status = "processing"
└───────┬────────┘
        │
        ▼
┌────────────────┐
│ LEAF 特徵提取   │ current_step = 2, analysis_status = "processing"
└───────┬────────┘
        │
        ▼
┌────────────────┐
│ 分類預測        │ current_step = 3, analysis_status = "processing"
└───────┬────────┘
        │
        ▼
┌────────────────┐
│ 完成           │ current_step = 4, analysis_status = "completed"
└────────────────┘
```

**錯誤處理**:
- 任何步驟失敗: `analysis_status = "error"`, `error_message` 記錄錯誤資訊
- 保留 `current_step` 指示失敗的步驟

---

## 6. 通訊協議

### 6.1 HTTP API

#### 6.1.1 上傳錄音

**請求**:
```http
POST /upload_recording HTTP/1.1
Content-Type: multipart/form-data

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="recording.wav"
Content-Type: audio/wav

[音訊檔案二進制資料]
------WebKitFormBoundary
Content-Disposition: form-data; name="device_id"

xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
------WebKitFormBoundary
Content-Disposition: form-data; name="duration"

10.0
------WebKitFormBoundary
Content-Disposition: form-data; name="file_size"

256000
------WebKitFormBoundary
Content-Disposition: form-data; name="file_hash"

abcdef1234567890...
------WebKitFormBoundary--
```

**回應**:
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "檔案上傳成功",
  "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
}
```

#### 6.1.2 下載錄音

**請求**:
```http
GET /download/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx HTTP/1.1
```

**回應**:
```http
HTTP/1.1 200 OK
Content-Type: audio/wav
Content-Disposition: attachment; filename="Device_20251014_120000.wav"

[音訊檔案二進制資料]
```

#### 6.1.3 建立排程

**請求**:
```http
POST /schedule HTTP/1.1
Content-Type: application/json

{
  "device_id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "interval": 5.0,    // 分鐘
  "duration": 10,     // 秒
  "count": 10         // null = 無限
}
```

**回應**:
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "排程創建成功",
  "next_recording": "2025-10-14T12:05:00+08:00"
}
```

### 6.2 WebSocket (SocketIO) 協議

#### 6.2.1 設備註冊

**Client → Server**:
```javascript
socket.emit('register_device', {
  client_id: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
  device_name: 'Device_name'
});
```

**Server → Client**:
```javascript
socket.emit('update_devices', {
  devices: [
    {
      id: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
      name: 'Device_name',
      status: 'IDLE'
    },
    // ... 更多設備
  ]
});
```

#### 6.2.2 錄音指令

**Server → Client**:
```javascript
socket.emit('record', {
  duration: 10  // 秒
});
```

#### 6.2.3 新錄音通知

**Server → All Clients**:
```javascript
socket.emit('new_recording', {
  id: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
  filename: 'Device_20251014_120000.wav',
  duration: 10.0,
  timestamp: '2025-10-14T12:00:00+08:00',
  device_id: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
  upload_complete: true,
  file_size: 256000,
  file_hash: 'abcdef1234567890...'
});
```

---

## 7. 部署架構

### 7.1 Docker Compose 部署

#### 7.1.1 服務清單

```yaml
services:
  # MongoDB 資料庫
  mongodb:
    image: mongo:6.0
    container_name: mongodb_web_ui
    ports:
      - "27020:27017"
    volumes:
      - mongodb_data:/data/db
    environment:
      MONGO_INITDB_ROOT_USERNAME: web_ui
      MONGO_INITDB_ROOT_PASSWORD: hod2iddfsgsrl
      MONGO_INITDB_DATABASE: web_db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app_network

  # Flask 前端
  flask_frontend:
    build:
      context: ./a_sub_system/frontend
      dockerfile: Dockerfile
    container_name: flask_frontend
    ports:
      - "5000:5000"
    volumes:
      - uploads:/app/uploads
    environment:
      - MONGODB_HOST=mongodb
      - MONGODB_PORT=27017
      - MONGODB_USERNAME=web_ui
      - MONGODB_PASSWORD=hod2iddfsgsrl
      - PYTHONUNBUFFERED=1
    depends_on:
      mongodb:
        condition: service_healthy
    networks:
      - app_network

  # 分析後端
  analysis_backend:
    build:
      context: ./a_sub_system/analysis_service
      dockerfile: Dockerfile
    container_name: analysis_backend
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    environment:
      - MONGODB_HOST=mongodb
      - MONGODB_PORT=27017
      - MONGODB_USERNAME=web_ui
      - MONGODB_PASSWORD=hod2iddfsgsrl
      - PYTHONUNBUFFERED=1
    depends_on:
      mongodb:
        condition: service_healthy
    networks:
      - app_network

networks:
  app_network:
    driver: bridge

volumes:
  mongodb_data:
  uploads:
  logs:
```

#### 7.1.2 啟動命令

```bash
# 啟動所有服務
docker-compose up -d

# 查看服務狀態
docker-compose ps

# 查看日誌
docker-compose logs -f

# 停止服務
docker-compose down

# 停止並刪除所有資料
docker-compose down -v
```

### 7.2 獨立部署

#### 7.2.1 MongoDB 獨立啟動

```bash
docker run -d \
  --name my-mongo \
  -p 27020:27017 \
  -e MONGO_INITDB_ROOT_USERNAME=web_ui \
  -e MONGO_INITDB_ROOT_PASSWORD=hod2iddfsgsrl \
  -e MONGO_INITDB_DATABASE=web_db \
  mongo:6
```

#### 7.2.2 Flask Frontend 獨立啟動

```bash
cd a_sub_system/frontend
python flask_main.py
```

#### 7.2.3 Analysis Backend 獨立啟動

```bash
cd a_sub_system/analysis_service
python analysis_main.py
```

#### 7.2.4 Edge Client 啟動

```bash
cd a_sub_system/edge_client
python edge_client.py
```

### 7.3 生產環境建議

#### 7.3.1 反向代理 (Nginx)

```nginx
server {
    listen 80;
    server_name your-domain.com;

    # Flask Frontend
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # SocketIO
    location /socket.io {
        proxy_pass http://localhost:5000/socket.io;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_buffering off;
    }
}
```

#### 7.3.2 進程管理 (Supervisor)

```ini
[program:flask_frontend]
command=/path/to/venv/bin/python flask_main.py
directory=/path/to/a_sub_system/frontend
autostart=true
autorestart=true
stderr_logfile=/var/log/flask_frontend.err.log
stdout_logfile=/var/log/flask_frontend.out.log

[program:analysis_backend]
command=/path/to/venv/bin/python analysis_main.py
directory=/path/to/a_sub_system/analysis_service
autostart=true
autorestart=true
stderr_logfile=/var/log/analysis_backend.err.log
stdout_logfile=/var/log/analysis_backend.out.log
```

---

## 8. 安全性設計

### 8.1 檔案完整性驗證

#### SHA-256 雜湊驗證流程

1. **邊緣設備端**:
   ```python
   # 計算檔案雜湊值
   file_hash = hashlib.sha256(file_data).hexdigest()
   file_size = len(file_data)

   # 上傳時附帶
   data = {
       'file_size': file_size,
       'file_hash': file_hash
   }
   ```

2. **伺服器端**:
   ```python
   # 接收檔案後重新計算
   uploaded_data = file.read()
   uploaded_size = len(uploaded_data)
   uploaded_hash = hashlib.sha256(uploaded_data).hexdigest()

   # 驗證
   if uploaded_size != expected_size or uploaded_hash != expected_hash:
       return jsonify({'error': '檔案上傳不完整或已被修改'}), 400
   ```

### 8.2 存取控制

#### MongoDB 認證
```python
MONGODB_CONFIG = {
    'username': 'web_ui',
    'password': 'hod2iddfsgsrl'
}
```

**建議**:
- 使用環境變數管理敏感資訊
- 定期更換密碼
- 使用強密碼策略

#### CORS 設定
```python
socketio = SocketIO(app, cors_allowed_origins="*")
```

**生產環境建議**:
```python
socketio = SocketIO(app, cors_allowed_origins=[
    "https://your-domain.com",
    "https://admin.your-domain.com"
])
```

### 8.3 檔案安全

#### 檔案名稱清理
```python
from werkzeug.utils import secure_filename

filename = secure_filename(file.filename)
```

#### 檔案類型驗證
```python
ALLOWED_EXTENSIONS = {'wav', 'mp3', 'flac'}

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
```

### 8.4 防止重複處理

使用原子性操作認領記錄:
```python
def try_claim_record(self, analyze_uuid):
    """嘗試認領記錄（原子操作）"""
    result = self.collection.update_one(
        {
            'AnalyzeUUID': analyze_uuid,
            'processing_worker': {'$exists': False}
        },
        {
            '$set': {
                'processing_worker': self.worker_id,
                'claim_time': datetime.utcnow()
            }
        }
    )
    return result.modified_count > 0
```

---

## 9. 擴展性設計

### 9.1 水平擴展

#### 9.1.1 Flask Frontend 擴展

使用負載平衡器（如 Nginx）分散請求:

```nginx
upstream flask_backend {
    server 127.0.0.1:5000;
    server 127.0.0.1:5001;
    server 127.0.0.1:5002;
}

server {
    location / {
        proxy_pass http://flask_backend;
    }
}
```

**注意事項**:
- SocketIO 需要啟用 sticky session
- 共享狀態需使用 Redis 等外部儲存

#### 9.1.2 Analysis Backend 擴展

支援多實例並行處理:

```bash
# 啟動多個分析服務實例
python analysis_main.py &  # Instance 1
python analysis_main.py &  # Instance 2
python analysis_main.py &  # Instance 3
```

**防重複機制**:
- 使用 MongoDB 原子操作認領記錄
- 每個實例獨立的 worker_id
- `processing_records` 集合防止同實例重複

### 9.2 垂直擴展

#### 9.2.1 增加並發處理能力

調整配置參數:
```python
SERVICE_CONFIG = {
    'max_concurrent_tasks': 10,  # 增加工作執行緒數
}
```

#### 9.2.2 GPU 加速

啟用 GPU 進行 LEAF 特徵提取:
```python
LEAF_CONFIG = {
    'device': 'cuda',  # 使用 GPU
    'batch_size': 64   # 增加批次大小
}
```

### 9.3 資料庫優化

#### 9.3.1 索引優化

```javascript
// 複合索引用於頻繁查詢
db.recordings.createIndex({
    "current_step": 1,
    "analysis_status": 1
});

// 部分索引（僅索引待處理記錄）
db.recordings.createIndex(
    { "current_step": 1 },
    { partialFilterExpression: { "current_step": { $lt: 4 } } }
);
```

#### 9.3.2 分片 (Sharding)

對於大量資料，可考慮 MongoDB 分片:
```javascript
// 以 device_id 作為分片鍵
sh.shardCollection("web_db.recordings", {
    "info_features.device_id": 1
});
```

### 9.4 快取策略

#### 9.4.1 Redis 快取

快取頻繁查詢的資料:
```python
# 快取設備列表
redis_client.set('devices', json.dumps(device_list), ex=60)

# 快取錄音統計資訊
redis_client.set('statistics', json.dumps(stats), ex=300)
```

#### 9.4.2 CDN 靜態資源

將靜態資源（JS, CSS, 圖片）部署到 CDN。

---

## 10. 附錄

### 10.1 系統需求

#### 硬體需求

**Flask Frontend**:
- CPU: 2 核心以上
- RAM: 4GB 以上
- 儲存: 10GB 以上（不含音訊檔案）

**Analysis Backend**:
- CPU: 4 核心以上（建議 8 核心）
- RAM: 16GB 以上
- GPU: 選配（NVIDIA GPU with CUDA support）
- 儲存: 20GB 以上

**MongoDB**:
- CPU: 2 核心以上
- RAM: 8GB 以上
- 儲存: 依據音訊檔案數量（建議 SSD）

**Edge Client**:
- CPU: 1 核心以上
- RAM: 512MB 以上
- 音訊輸入設備

#### 軟體需求

- Python 3.9+
- MongoDB 6.0+
- Docker 20.10+ (選配)
- Docker Compose 2.0+ (選配)

### 10.2 依賴套件版本

詳見 `requirements.txt` (83 個套件)。

主要套件:
- Flask==3.0.3
- Flask-SocketIO==5.3.6
- pymongo==4.15.1
- torch==2.8.0+cu129
- torchaudio==2.8.0
- scikit-learn==1.7.2
- librosa==0.11.0
- speechbrain==1.0.3

### 10.3 目錄結構

```
CPC_server_collectorSYS/
├── a_sub_system/
│   ├── frontend/                    # Flask 前端
│   │   ├── flask_main.py            # 主程式
│   │   ├── routes.py                # HTTP 路由
│   │   ├── socket_events.py         # SocketIO 事件
│   │   ├── models.py                # 資料模型
│   │   ├── config.py                # 配置檔案
│   │   ├── shared_state.py          # 共享狀態
│   │   ├── gridfs_handler.py        # GridFS 處理器
│   │   ├── utils.py                 # 工具函數
│   │   ├── templates/               # HTML 模板
│   │   │   ├── base.html
│   │   │   ├── dashboard.html
│   │   │   ├── index.html
│   │   │   ├── play.html
│   │   │   └── schedule_management.html
│   │   ├── static/                  # 靜態資源
│   │   └── Dockerfile
│   │
│   ├── analysis_service/            # 分析後端
│   │   ├── analysis_main.py         # 主程式
│   │   ├── analysis_pipeline.py     # 分析流程
│   │   ├── mongodb_watcher.py       # MongoDB 監聽器
│   │   ├── config.py                # 配置檔案
│   │   ├── gridfs_handler.py        # GridFS 處理器
│   │   ├── processors/              # 處理器模組
│   │   │   ├── step1_slicer.py      # 音訊切割
│   │   │   ├── step2_leaf.py        # LEAF 特徵提取
│   │   │   └── step3_classifier.py  # 分類器
│   │   ├── utils/                   # 工具模組
│   │   │   ├── logger.py            # 日誌工具
│   │   │   └── mongodb_handler.py   # MongoDB 操作
│   │   ├── models/                  # 模型檔案
│   │   │   └── rf_model_cpu_final.pkl
│   │   └── Dockerfile
│   │
│   ├── edge_client/                 # 邊緣設備客戶端
│   │   ├── edge_client.py           # 主程式
│   │   ├── device_config.json       # 設備配置
│   │   └── temp_wav/                # 臨時音訊目錄
│   │
│   ├── batch_upload/                # 批次上傳工具
│   │   ├── batch_upload.py
│   │   └── config.py
│   │
│   ├── batch_delete/                # 批次刪除工具
│   │   ├── batch_delete.py
│   │   └── batch_delete_config.py
│   │
│   └── train/                       # 模型訓練
│       └── RF/
│           ├── train_rf_model.py
│           ├── evaluate_model.py
│           └── quick_start.py
│
├── debug_tools/                     # 除錯工具
├── docker-compose.yml               # Docker Compose 配置
├── requirements.txt                 # Python 依賴
├── .gitignore
└── 系統架構文檔.md                   # 本文檔
```

### 10.4 常見問題 (FAQ)

#### Q1: MongoDB 連接失敗怎麼辦？
**A**:
1. 檢查 MongoDB 是否正在運行: `docker ps | grep mongo`
2. 檢查連接配置是否正確 (host, port, username, password)
3. 檢查防火牆設定
4. 查看 MongoDB 日誌: `docker logs mongodb_web_ui`

#### Q2: 分析服務沒有自動處理新錄音？
**A**:
1. 檢查 `analysis_status` 是否為 "pending"
2. 檢查 `current_step` 是否為 0
3. 查看分析服務日誌是否有錯誤
4. 確認 `use_change_stream` 配置是否正確
5. 如果使用輪詢模式，檢查 `polling_interval` 設定

#### Q3: 如何增加分析服務的處理速度？
**A**:
1. 增加 `max_concurrent_tasks` (工作執行緒數)
2. 啟用 GPU 加速 (修改 `LEAF_CONFIG['device']` 為 'cuda')
3. 增加批次大小 (修改 `LEAF_CONFIG['batch_size']`)
4. 啟動多個分析服務實例

#### Q4: GridFS 檔案過大導致性能問題？
**A**:
1. 調整 GridFS chunk size
2. 考慮使用物件儲存服務（如 S3, MinIO）
3. 定期清理舊檔案
4. 實施資料歸檔策略

#### Q5: 如何備份與還原資料？
**A**:

備份:
```bash
# 備份 MongoDB 資料庫
docker exec mongodb_web_ui mongodump \
  --username=web_ui \
  --password=hod2iddfsgsrl \
  --authenticationDatabase=admin \
  --db=web_db \
  --out=/backup

# 複製備份到本地
docker cp mongodb_web_ui:/backup ./mongodb_backup
```

還原:
```bash
# 複製備份到容器
docker cp ./mongodb_backup mongodb_web_ui:/backup

# 還原資料庫
docker exec mongodb_web_ui mongorestore \
  --username=web_ui \
  --password=hod2iddfsgsrl \
  --authenticationDatabase=admin \
  --db=web_db \
  /backup/web_db
```

### 10.5 效能指標

#### 預期效能

**Flask Frontend**:
- 同時連接設備: 50+ 個
- HTTP 請求處理: 1000+ req/s
- 檔案上傳速度: 依網路頻寬

**Analysis Backend**:
- 單執行緒處理速度: 1-2 個音訊/分鐘
- 3 執行緒並發: 3-6 個音訊/分鐘
- GPU 加速: 10-20 個音訊/分鐘

**MongoDB**:
- 讀取效能: 10000+ ops/s
- 寫入效能: 5000+ ops/s
- GridFS 檔案讀寫: 100+ MB/s

### 10.6 監控建議

#### 應用監控
- 使用 Prometheus + Grafana 監控系統指標
- 使用 ELK Stack 收集與分析日誌
- 監控 SocketIO 連接數與事件頻率
- 監控任務佇列長度與處理速度

#### 資料庫監控
- MongoDB 連接數
- 查詢效能 (slow queries)
- 索引使用率
- 儲存空間使用率
- GridFS 檔案數量與大小

#### 系統監控
- CPU 使用率
- 記憶體使用率
- 磁碟 I/O
- 網路頻寬
- Docker 容器健康狀態

### 10.7 版本歷史

- **v5.1.3.4** (2025-10-14): 當前版本，修復 UI
- **v5.1.3.3** (2025-10-08): UI 修復
- **v5.1.3.2** (2025-10-04): UI 修復
- **v5.1.3.1** (2025-10-03): UI 修復
- **v5.1.2.4** (2025-10-02): 簡化 MongoDB 記錄結構

---

## 結語

本文檔詳細描述了 CPC Server Collector System 的系統架構、核心組件、資料流程與部署方式。系統採用分層架構設計，具備良好的擴展性與維護性。

**關鍵特色**:
- 分散式音訊採集與管理
- 自動化三階段音訊分析流程
- 即時通訊與狀態更新
- GridFS 大檔案儲存
- 檔案完整性驗證
- Docker 容器化部署

**適用場景**:
- 音訊品質監控系統
- 異常音訊檢測平台
- 分散式音訊資料收集
- 音訊特徵分析研究

如有任何問題或建議，請聯繫開發團隊。

---

**文檔維護者**: Development Team
**聯絡方式**: [待補充]
**最後審閱**: 2025-10-14